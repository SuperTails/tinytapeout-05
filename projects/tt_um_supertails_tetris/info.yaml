--- 
# Tiny Tapeout project information
project:
  wokwi_id:    0        # If using wokwi, set this to your project's ID

# If using an HDL, set wokwi_id as 0 and uncomment and list your source files here. 
# Source files must be in ./src and you must list each source file separately
  source_files:        
    - main.sv 
    - collision.sv
    - buttons.sv
    - puyo.sv
    - defs.svh
  top_module:  "tt_um_supertails_tetris"      # Put the name of your top module here, must start with "tt_um_". Make it unique by including your github username

# How many tiles your design occupies? A single tile is about 167x108 uM.
  tiles: "1x1"    # Valid values: 1x1, 1x2, 2x2, 3x2, 4x2 or 8x2

# Keep a track of the submission yaml
yaml_version: 4

# As everyone will have access to all designs, try to make it easy for someone new to your design to know what
# it does and how to operate it. This info will be automatically collected and used to make a datasheet for the chip.
#
# Here is a great example: https://github.com/davidsiaw/tt02-davidsiaw-stackcalc/blob/38c5647f83aad2aec675d566aa3d67b98f0aac81/info.yaml
documentation: 
  author:       "Carson Swoveland"      # Your name
  title:        "Cleary Line Game"      # Project title
  language:     "SystemVerilog" # other examples include Verilog, Amaranth, VHDL, etc
  description:  "Implements the second-most-popular game of all time in hardware"      # Short description of what your project does

# Longer description of how the project works. You can use standard markdown format.
  how_it_works: |
      This project implements a game in which 4-tile pieces fall from the top of the screen
      and land at the bottom.
      Filling up a row of the grid clears that row.
      Any resemblance to famous 1985 games is purely coincidental.

      All gameplay logic is synchronized to the VGA output,
      which uses a very nonstandard resolution due to PLL limitations on my test FPGA.
      There's only enough area to maintain a ring buffer containing the current row of placed tiles (call it the "row buffer")
      along with whatever game piece is currently falling (the "falling piece").

      On alternating frames the player is allowed to move the falling piece and collisions are checked.

      As the "scanning beam" moves along, the row buffer is shifted around in a loop.
      Checking for collisions and full rows is done one tile at a time just on the head of the row buffer.
      If, by the end of the frame, any collision has occurred, the previous move is undone.
      The falling piece is also possibly written to the grid and replaced with a new falling piece (more on that later).
      If any rows are full, the entire grid above that row gets written downwards.

      The grid data is stored externally. I used a Teensy 4.1 as my external memory,
      because I didn't have enough area, pins, or time to actually implement an SPI SRAM interface.
      The external memory is double-buffered, and the game reads from- and writes to- alternating buffers on every frame.
      This is so that, when a row is cleared, we can write rows downwards without overwriting any data.

      The memory interface uses a somewhat strange protocol.
      There are three control pins in addition to a 3.125 MHz clock and address/data lines:
      - Start
      - Continue
      - Write Enable
      Everything is rising-edge-triggered.
      At the beginning of a row access, the ASIC will:
      - hold start high,
      - assert a row address on A0-A5, and
      - hold write enable high for ASIC->Memory writing and low for Memory->ASIC reading.
      When reading, the memory will output a tile from the selected row on the data lines, starting at the left column.
      When the continue signal is held high across a clock edge, the memory will move on to the next column.
      Writing works similarly except the ASIC asserts a tile to be stored at increasing columns.


# Instructions on how someone could test your project, include things like what buttons do what and how to set the clock if needed
  how_to_test:  |
      You'll need:
      - several buttons
      - some kind of (very fast!!) external memory simulator (a Teensy 4.1 or an FPGA), and
      - a few resistors for the VGA output.

      Connect HSync and VSync on the VGA output directly to the HSync/VSync pins on a VGA connector.
      For the red, green, and blue pins, be sure to add a series resistor between them and the connector.
      VGA signals have 75-ohm termination, so at 3.3V gpio a 270ohm or larger resistor will limit the signal
      to the appropriate 0.7V level.
      Note that 800x600@72Hz is very unusual. It worked on all (read: the single) VGA monitors I tested,
      and didn't work on all (read: the single) VGA->HDMI adapters I tested.

      The buttons can be connected to the appropriate inputs with simple pulldowns.
      Debouncing is done internally.

      For the memory interface, follow the steps in
      [the memory interface repo](https://github.com/SuperTails/cleary-line-peripheral).

      Now you should be able to play the game! Press any button to start after a game over.

      If you can see the falling piece and the grid, but pieces disappear after hitting the bottom
      or pieces appear at random in the grid, there's likely a problem with the memory interface.



# A description of what the inputs do (e.g. red button, SPI CLK, SPI MOSI, etc).
  inputs:               
    - Move Left
    - Move Down
    - Move Left
    - Spin Counterclockwise
    - Spin Clockwise
    - none
    - none
    - none
# A description of what the outputs do (e.g. status LED, SPI MISO, etc)
  outputs:
    - VGA HSync
    - VGA VSync
    - VGA Red
    - VGA Green
    - VGA Blue
    - Memory Start
    - Memory Continue
    - Memory Write Enable
# A description of what the bidirectional I/O pins do (e.g. I2C SDA, I2C SCL, etc)
  bidirectional:
    - A0/D0
    - A1/D1
    - A2/D2
    - A3
    - A4
    - A5
    - none
    - Memory Clock (always output)

# The following fields are optional
  tag:          ""      # comma separated list of tags: test, encryption, experiment, clock, animation, utility, industrial, pwm, fpga, alu, microprocessor, risc, riscv, sensor, signal generator, fft, filter, music, bcd, sound, serial, timer, random number generator, calculator, decoder, counter, puzzle, multiplier, game, oscillator,
  external_hw:  ""      # Describe any external hardware needed
  discord:      "_salix"      # Your discord handle, used for communication and automatically assigning tapeout role after a submission
  doc_link:     ""      # URL to longer form documentation, eg the README.md in your repository
  clock_hz:     6250000       # Clock frequency in Hz (if required)
  picture:      ""      # relative path to a picture in your repository (must be 512kb or less)
